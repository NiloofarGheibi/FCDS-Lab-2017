package main

import (
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"unicode"
)

var fin *string

//Grammar is present the CFG grammars
//ex:  S-> AB
//     LeftSymbol: S
//     RightSymbol: "AB"
type Grammar struct {
	LeftSymbol  string
	RightSymbol string
}

type G struct {
	nonterminals []string
	terminals    []string
	rules        []string
	start        string
}

//We use matrix to store our CYK result and maniplate it
//ex: X_11 -> A ==> map[MatrixIndicator{ X_axi: 1, Y_axi: 1}] = "A"
type MatrixIndicator struct {
	X_axi int
	Y_axi int
}

//Using map to handle matrix result
type MatrixResult map[MatrixIndicator]string

type CYK struct {
	Grammars     []Grammar
	CYKResult    MatrixResult
	InputString  string
	StartSymbol  string
	Nonterminals []string
	Terminals    []string
	Matrix       [][]string
}

func must(err error) {
	if err != nil {
		log.Print(err)
	}
}

func NewCYK(startSymbol string) *CYK {
	newCYK := &CYK{StartSymbol: startSymbol}
	newCYK.CYKResult = make(map[MatrixIndicator]string)
	return newCYK
}

func (c *CYK) SetTerminals(terminals []string) {
	c.Terminals = terminals
}

func (c *CYK) SetNonTerminals(nonterminal []string) {
	c.Nonterminals = nonterminal
}

func (c *CYK) SetStartSymbol(startSymbol string) {
	startSymbol = startSymbol
}

// Find terminal assign variable
// ex: A->a  using `a` find A
func (c *CYK) findTerminalAssign(terminal string) string {
	var retList string
	for _, targetG := range c.Grammars {
		if strings.Contains(targetG.RightSymbol, terminal) {
			//fmt.Println("find terminal assign", targetG.LeftSymbol)
			retList = fmt.Sprintf("%s%s", retList, targetG.LeftSymbol)
		}
	}

	return retList
}

// Find variable assign, difference with find terminal it's needs equal not contains
// S -> AB, only use "AB" -> "S"
func (c *CYK) findVariableAssign(symbol string) string {
	var retSlice string
	for _, targetG := range c.Grammars {
		//fmt.Println(" grammarR=", targetG.RightSymbol, " symbol=", symbol)
		if strings.Contains(targetG.RightSymbol, symbol) { //symbol == targetG.RightSymbol {
			retSlice = fmt.Sprintf("%s%s", retSlice, targetG.LeftSymbol)
			fmt.Println("get Left=", retSlice)
		}
	}
	return retSlice
}

//To eval if string is terminal not variable
// func (c *CYK) isTerminal(testString string) bool {
// 	return testString == strings.ToLower(testString)
// }

//To eval if string is terminal not variable
func (c *CYK) isTerminal(testString string) bool {
	for _, t := range c.Terminals {
		if t == testString {
			return true
		}
	}
	return false
}

//Insert grammar in this CYK
// Ex: S->{AB}  InputGrammar("S", "AB")

func (c *CYK) InputGrammar(leftSymbol string, rightSymbols string) {
	newGrammar := Grammar{LeftSymbol: leftSymbol, RightSymbol: rightSymbols}
	//log.Println("left:", newGrammar.LeftSymbol, "right:", newGrammar.RightSymbol)
	c.Grammars = append(c.Grammars, newGrammar)
}

// Take input to run CYK algorithm and eval if this input can be generated by this CFG
func (c *CYK) Eval(input string) bool {
	c.runCYK(input)
	return c.evalCYKResult()
}

func (c *CYK) getResultMatrix(x, y int) (string, error) {
	val, ok := c.CYKResult[MatrixIndicator{X_axi: x, Y_axi: y}]
	if ok {
		return val, nil
	} else {
		//fmt.Println("index x=", x, " y=", y, " is not exist!.")
		return "", errors.New("Not exist!")
	}
}

func (c *CYK) setResultMatrix(x, y int, val string) {
	c.CYKResult[MatrixIndicator{X_axi: x, Y_axi: y}] = val
}

func (c *CYK) setMatrix(x, y int, val string) {
	c.Matrix[x][y] = val
}
func (c *CYK) getMatrix(x, y int) string {
	if c.Matrix[x][y] != "" {
		return c.Matrix[x][y]
	} else {
		return ""
	}

}

// Run CYK algorithm
func (c *CYK) runCYK(input string) {
	c.InputString = input
	//Start to calculate X_11, X_22, X_33
	for i := 0; i < len(input); i++ {
		variable := c.findTerminalAssign(string(input[i]))
		c.setResultMatrix(i, i, variable)
	}

	//start triangle calculate
	for loop := 1; loop <= len(c.InputString); loop++ {
		for i := 0; i < len(c.InputString)-loop; i++ {
			j := i + loop
			//fmt.Println("i=", i, " j=", j)
			var totalTargets []string
			for k := 1; k <= j; k++ {

				firstVal, _ := c.getResultMatrix(i, i+k-1)
				secondVal, _ := c.getResultMatrix(i+k, j)
				products := arrayProduction(firstVal, secondVal)
				for _, v := range products {
					totalTargets = append(totalTargets, v)
				}
				//fmt.Println("total =", totalTargets)
			}

			var result string
			for _, symbol := range totalTargets {

				fmt.Println("i=", i, " j=", j, " symbol=", symbol)
				targetSymbol := c.findVariableAssign(symbol)
				if !(targetSymbol == "") {
					if !strings.Contains(result, targetSymbol) {
						result = fmt.Sprintf("%s%s", result, targetSymbol)
						fmt.Println("result = ", result)
					}
				}

			}

			c.setResultMatrix(i, j, result)

		}
	}
}

func removeDuplicates(elements []string) []string {
	// Use map to record duplicates as we find them.
	encountered := map[string]bool{}
	result := []string{}

	for v := range elements {
		if encountered[elements[v]] == true {
			// Do not add duplicate.
		} else {
			// Record this element as an encountered element.
			encountered[elements[v]] = true
			// Append to result slice.
			result = append(result, elements[v])
		}
	}
	// Return the new slice.
	return result
}
func arrayProduction(str1, str2 string) []string {
	var ret []string
	for i := 0; i < len(str1); i++ {
		for j := 0; j < len(str2); j++ {
			restr := fmt.Sprintf("%s%s", string(str1[i]), string(str2[j]))
			ret = append(ret, restr)
		}
	}
	return removeDuplicates(ret)
}

// Eval CYK result and make sure latest CYK Result only contain variable not assign to terminal
// ex: latest result is "S" which S->AB
func (c *CYK) evalCYKResult() bool {
	finalResult, err := c.getResultMatrix(0, len(c.InputString)-1)

	if err != nil {
		return false
	}

	fmt.Println("final:", finalResult)
	if strings.Contains(finalResult, c.StartSymbol) {
		return true
	}

	return false
}

// Print out the triangle result on CYK
func (c *CYK) PrintResult() {
	if len(c.CYKResult) == 0 {
		fmt.Println("We still not calculate CYK or no result...")
		return
	}

	fmt.Printf("1:")
	for i := 0; i < len(c.InputString); i++ {
		c.printResultMatrixElement(i, i)
	}
	fmt.Printf("\n")

	lineIndex := 2
	for loop := 1; loop < len(c.InputString); loop++ {

		fmt.Printf("%d:", lineIndex)
		for i := 0; i < len(c.InputString)-loop; i++ {
			j := i + loop
			c.printResultMatrixElement(i, j)
		}
		fmt.Printf("\n")
		lineIndex = lineIndex + 1
	}
}

func (c *CYK) printResultMatrixElement(i, j int) {
	fmt.Printf("\tX%d%d:{", i+1, j+1)

	results, err := c.getResultMatrix(i, j)
	if err != nil {
		fmt.Println("Empty result")
		return
	}
	for index, _ := range results {
		fmt.Printf("%s", string(results[index]))
		if index < len(results)-1 {
			fmt.Printf(",")
		}
	}
	fmt.Printf("}")
}

// READER

func (g *G) Start() string          { return g.start }
func (g *G) Rules() []string        { return g.rules }
func (g *G) Terminals() []string    { return g.terminals }
func (g *G) NonTerminals() []string { return g.nonterminals }

func Do(input string) (G, string) {
	grammar, inpstring := Split(input)
	return grammar, inpstring
}

func SpaceMap(str string) string {
	return strings.Map(func(r rune) rune {
		if unicode.IsSpace(r) {
			return -1
		}
		return r

	}, str)
}

func Split(input string) (G, string) {

	var grammar G

	split := strings.SplitAfter(input, "\n")

	// string to parse
	log.Println(split[0])
	instring := SpaceMap(split[0])
	//instring := split[0]

	// terminals
	terminals := strings.SplitAfter(split[1], " ")
	grammar.terminals = terminals
	for i, t := range terminals {
		grammar.terminals[i] = SpaceMap(t)
	}
	//grammar.terminals = terminals
	//grammar.terminals[len(terminals)-1] = SpaceMap(grammar.terminals[len(terminals)-1])
	log.Println(split[1])

	// non terminals
	nonterminals := strings.SplitAfter(split[2], " ")
	grammar.nonterminals = nonterminals
	for i, t := range nonterminals {
		grammar.nonterminals[i] = SpaceMap(t)
	}
	// grammar.nonterminals = nonterminals
	// grammar.nonterminals[len(nonterminals)-1] = SpaceMap(grammar.nonterminals[len(nonterminals)-1])
	log.Println(split[2])

	// start
	grammar.start = SpaceMap(split[3])
	log.Println(split[3])

	rules := make([]string, len(split)-3)
	j := 0
	for i := 4; i < len(split); i++ {
		rules[j] = SpaceMap(split[i])
		j++
		log.Println(split[i])
	}
	log.Printf("size %d \n", j)
	grammar.rules = rules

	return grammar, instring

}

func Rule_Parser(grammar G) ([]Grammar, map[string]bool, map[string]bool, map[string]string) {
	set_terminals := make(map[string]bool)
	set_nonterminals := make(map[string]bool)
	set_Mapping_Terminals := make(map[string]string)
	var rules []Grammar
	var r Grammar
	for _, rule := range grammar.rules {
		//log.Println(i)
		parts := strings.SplitAfter(rule, ":")

		if len(parts) == 2 {
			r.LeftSymbol = SpaceMap(strings.Trim(parts[0], ":"))
			r.RightSymbol = SpaceMap(parts[1])
			rules = append(rules, r)
			//log.Printf("right %s \t", r.RightSymbol)
			//log.Printf("left %s \n", r.LeftSymbol)
		}

	}
	for _, terminal := range grammar.terminals {
		set_terminals[SpaceMap(terminal)] = false
		set_Mapping_Terminals[SpaceMap(terminal)] = ""
	}

	for _, nonterminal := range grammar.nonterminals {
		set_nonterminals[SpaceMap(nonterminal)] = false
	}

	for _, rule := range rules {

		for _, terminal := range grammar.terminals {
			if len(rule.RightSymbol) == 1 && strings.ContainsAny(terminal, rule.RightSymbol) {
				set_terminals[SpaceMap(terminal)] = true
				set_Mapping_Terminals[SpaceMap(terminal)] = rule.LeftSymbol
				break
			}
		}

		for _, nonterminal := range grammar.nonterminals {
			//log.Println(rule.LeftSymbol, nonterminal)
			if strings.Contains(nonterminal, rule.LeftSymbol) {
				//log.Println("true")
				set_nonterminals[nonterminal] = true
				break
			}
		}
	}

	return rules, set_terminals, set_nonterminals, set_Mapping_Terminals
}

func CNF(rules []Grammar, set_terminals map[string]bool, set_nonterminals map[string]bool, set_Mapping_Terminals map[string]string, g G) []Grammar {
	cnf := rules
	// fmt.Println("copy", cnf)
	//var cnf []Grammar
	//var r Grammar
	alphabet := []string{}
	for i := 'A'; i < 'A'+26; i++ {
		if _, exist := set_nonterminals[string(i)]; !exist {
			alphabet = append(alphabet, string(i))
		}
	}
	//fmt.Println("ALPHABET = ", alphabet)
	// Checking non Terminals
	new_rules := []Grammar{}
	for _, terminal := range g.Terminals() {
		if set_terminals[terminal] == false {
			cnf = append(cnf, Grammar{alphabet[0], terminal})
			new_rules = append(new_rules, Grammar{alphabet[0], terminal})
			set_terminals[terminal] = true
			set_Mapping_Terminals[terminal] = alphabet[0]
			alphabet = alphabet[1 : len(alphabet)-1]
		}
	}

	comb_rules := []Grammar{}
	// More than 2 Non-Terminals
	for index, rule := range cnf {
		if len(rule.RightSymbol) > 2 {
			//fmt.Println("rule >= 2", rule.RightSymbol)
			split := strings.Split(rule.RightSymbol, "")
			//fmt.Println("split ", split)
			_ = index
			comb_rules = append(comb_rules, Grammar{alphabet[0], split[0] + split[1]})
			cnf[index] = Grammar{rule.LeftSymbol, alphabet[0] + split[2]}
			alphabet = alphabet[1 : len(alphabet)-1]
			//log.Printf("right %s \t", r.RightSymbol)
			//log.Printf("left %s \n", r.LeftSymbol)
		}
	}
	//fmt.Println(cnf)
	for _, r := range cnf {
		fmt.Println(r)
	}
	fmt.Println("++++++++++++++")

	for _, r := range comb_rules {
		//fmt.Println(r)
		cnf = append(cnf, r)
	}
	//fmt.Println("++++++++++++++")

	for _, r := range cnf {
		fmt.Println(r)
	}
	// fmt.Println("++++++++++++++")
	// fmt.Println("terminals", set_Mapping_Terminals)
	// fmt.Println("SET terminals", set_terminals)
	// Subsituting with terminals
	for index, rule := range cnf {
		if len(rule.RightSymbol) == 2 {
			split := strings.Split(rule.RightSymbol, "")
			//fmt.Println("split", split)
			if set_terminals[split[0]] {
				//fmt.Println("split[0]", split[0])
				//cnf = append(cnf, Grammar{rule.LeftSymbol, set_Mapping_Terminals[split[0]] + split[1]})
				cnf[index] = Grammar{rule.LeftSymbol, set_Mapping_Terminals[split[0]] + split[1]}
			} else {
				if set_terminals[split[1]] {
					//fmt.Println("split[1]", split[1])
					//cnf = append(cnf, Grammar{rule.LeftSymbol, split[0] + set_Mapping_Terminals[split[1]]})
					cnf[index] = Grammar{rule.LeftSymbol, split[0] + set_Mapping_Terminals[split[1]]}
				}

			}
			if set_terminals[split[0]] && set_terminals[split[1]] {
				cnf[index] = Grammar{rule.LeftSymbol, set_Mapping_Terminals[split[0]] + set_Mapping_Terminals[split[1]]}
			}
		}
	}

	// for _, r := range cnf {
	// 	fmt.Println(r)
	// }
	// fmt.Println("++++++++++++++")
	set_empty := []Grammar{}
	// fmt.Println(set_Rules)
	for _, rule := range cnf {
		if rule.RightSymbol == "" {
			for _, r := range cnf {
				if strings.Contains(r.RightSymbol, rule.LeftSymbol) {
					split := strings.Split(r.RightSymbol, "")
					//cnf = append(cnf[:index], cnf[index+1:]...)
					if split[0] == rule.LeftSymbol {
						set_empty = append(set_empty, Grammar{r.LeftSymbol, split[1]})
					} else {
						set_empty = append(set_empty, Grammar{r.LeftSymbol, split[0]})
					}

				}
				//cnf = append(cnf[:index], cnf[index+1:]...)
			}
		}
	}
	//fmt.Println("empty", set_empty)
	for _, rule := range set_empty {
		cnf = append(cnf, rule)
	}
	// for _, r := range cnf {
	// 	fmt.Println(r)
	// }
	// fmt.Println("++++++++++++++")

	set_Rules := []Grammar{} //make(map[string]string)
	for _, rule := range cnf {
		// Single non Temrinals
		if len(rule.RightSymbol) == 1 && set_terminals[rule.RightSymbol] == false {
			for _, r := range cnf {
				if r.LeftSymbol == rule.RightSymbol {
					//cnf = append(cnf[:index], cnf[index+1:]...)
					set_Rules = append(set_Rules, Grammar{rule.LeftSymbol, r.RightSymbol})
				}

			}

		}
	}

	//fmt.Println(set_Rules)
	for _, rule := range set_Rules {
		cnf = append(cnf, rule)
	}
	// for _, r := range cnf {
	// 	fmt.Println(r)
	// }
	// fmt.Println("++++++++++++++")

	set_Ruless := []Grammar{}
	for _, rule := range set_Rules {
		// Single non Temrinals
		if len(rule.RightSymbol) == 1 && set_terminals[rule.RightSymbol] == false {
			for _, r := range cnf {
				if r.LeftSymbol == rule.RightSymbol {
					//cnf = append(cnf[:index], cnf[index+1:]...)
					set_Ruless = append(set_Ruless, Grammar{rule.LeftSymbol, r.RightSymbol})
				}

			}

		}
	}
	// //fmt.Println("2nd round", set_Ruless)

	for _, rule := range set_Ruless {
		cnf = append(cnf, Grammar{rule.LeftSymbol, rule.RightSymbol})
	}
	// for _, r := range cnf {
	// 	fmt.Println(r)
	// }
	// fmt.Println("++++++++++++++")
	// Removing single NonTerminals
	final := []Grammar{}
	for _, rule := range cnf {
		if len(rule.RightSymbol) == 1 && set_terminals[rule.RightSymbol] == false {
			if strings.ToUpper(rule.RightSymbol) == rule.RightSymbol {
				continue
				//fmt.Println("right", cnf[index].RightSymbol)
			}
		} else {
			final = append(final, rule)
		}
	}

	return final

}

// READER

func main() {
	file, err := ioutil.ReadAll(os.Stdin)
	must(err)
	grammar, input := Do(string(file))
	rules, set_terminals, set_nonterminals, set_Mapping_Terminals := Rule_Parser(grammar)
	// fmt.Println("terminals", set_terminals)
	// fmt.Println("nonterminals", set_nonterminals)
	// fmt.Println("A B C terminals", set_Mapping_Terminals)
	rules = CNF(rules, set_terminals, set_nonterminals, set_Mapping_Terminals, grammar)
	cyk := NewCYK(grammar.Start())
	_ = input
	for _, r := range rules {
		fmt.Println(r)
	}
	for _, rule := range rules {
		cyk.InputGrammar(SpaceMap(rule.LeftSymbol), SpaceMap(rule.RightSymbol))
	}
	cyk.SetTerminals(grammar.Terminals())
	cyk.SetNonTerminals(grammar.NonTerminals())
	log.Println(input)
	result := cyk.Eval(input)
	log.Println("Result:", result)
	// cyk.PrintResult()
}
